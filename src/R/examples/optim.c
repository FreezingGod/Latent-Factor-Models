/*
	Copyright (c) 2011, Yahoo! Inc.  All rights reserved.
	Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.

    Author: Bee-Chung Chen
*/

#include <R.h>
#include <Rmath.h>
#include <R_ext/Applic.h>

/****************************************************************************
 * Example of how to use lbfgsb
 *
 * f(x) = sum_i (x[i] - w[i])^2
 *
 */
// Data structure for the weight vector
typedef struct {
	double* value;
	int num;
} DataVector;

// Objective function
double sum_of_squares(
	int size,       // input: number of variables
	double *vector, // input: vector of variable values
	void *obj       // input: data
){
	DataVector* w = (DataVector*)obj;
	if(w->num != size) error("w->num != size");
	double ans = 0;
	for(int i=0; i<size; i++) ans += (vector[i] - w->value[i])*(vector[i] - w->value[i]);
	return ans;
}

// Gradient function
void sum_of_squares_gr(
	int size,         // input: number of variables
	double *vector,   // input: vector of variable values
	double *gradient, // output: vector of gradient values evaluated at the point specified above
	void *obj         // data
){
	DataVector* w = (DataVector*)obj;
	if(w->num != size) error("w->num != size");
	for(int i=0; i<size; i++) gradient[i] = 2 * (vector[i] - w->value[i]);
}

// Interface function with R
void min_sum_of_squares(
	double *x,         // input and output
	const double *w,   // input
	const double *lower,  // input: lower bound
	const double *upper,  // input: upper bound
	const int *num,    // input
	const int *trace,  // input
	const int *nREPORT // input
){
	if(*trace > 0){
		Rprintf("Start min_sum_of_squares\n");
	}

	DataVector data;
	data.value = (double*)w;
	data.num   = *num;

	int *nbd = (int*)Calloc(*num, int);  for(int i=0; i<*num; i++) nbd[i] = 2; // has both lower and upper bounds
	double Fmin;
	int fail, fncount, grcount;
	char msg[100] = "";

	lbfgsb(
	    *num,  //  INPUT: number of variables
	    5,     //  INPUT: maximum number of variable metric corrections used to define the limited memory matrix;
	           //         i.e., number of BFGS updates retained in the "L-BFGS-B" method (R's DEFAULT: 5)
	    x,     //  INPUT/OUTPUT: (n x 1) initial variable values -> final variable values
	    (double*)lower, //  INPUT: (n x 1) lower bound of x
	    (double*)upper, //  INPUT: (n x 1) upper bound of x
	    nbd,   //  INPUT: (n x 1) bound type
	           //       nbd[i]=0 if x[i] is unbounded,
	           //              1 if x[i] has only a lower bound,
	           //              2 if x[i] has both lower and upper bounds, and
	           //              3 if x[i] has only an upper bound.
		&Fmin, // OUTPUT: final objective value
		sum_of_squares,    //  INPUT: Objective function
		sum_of_squares_gr, //  INPUT: Gradient of the objective function
	    &fail, // OUTPUT: 0 means success
		&data, //  INPUT: The object to be passed into fminfn and fmingr.
	    1e7,   //  INPUT: The iteration will stop when
	           //           (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
	           //         where epsmch is the machine precision, which is automatically
	           //         generated by the code. Typical values for factr: 1.d+12 for
	           //         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely high accuracy.
	           //         (R's DEFAULT: 1e7; that is a tolerance of about 1e-8)
	    0,     //  INPUT: The iteration will stop when
	           //           max{|proj g_i | i = 1, ..., n} <= pgtol
	           //         where pg_i is the ith component of the projected gradient.
	           //         It is a tolerance on the projected gradient in the current search direction.
	           //         (R's DEFAULT: 0, when the check is suppressed)
		&fncount, // OUTPUT: Number of calls of fminfn
	    &grcount, // OUTPUT: Number of calls of fmingr
	    100,      //  INPUT: Maximum number of iterations (R's DEFAULT: 100)
	    msg,      //  ??   : Allocation at least 100 characters
		*trace,   //  INPUT: verbose level (0: least message); total: 6 levels
	    *nREPORT  //  INPUT: The frequency of reports. (R's DEFAULT: 10; every 10 iterations)
	);

	if(*trace > 0){
		Rprintf("      fail=%d, fncount=%d, grcount=%d\n", fail, fncount, grcount);
		Rprintf("End   min_sum_of_squares\n");
	}
}
